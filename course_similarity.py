"""
Group 20: SCOURSE
Members : Abhinaav Singh(abhinaas), Akshay Bahadur(akshayba), Chirag Huria(churia), Naman Arora(namana)
This script preprares the master data for searching similar courses to the query entered by the user. 
Uses cosine similarity generated by the docsim script.
"""

import numpy as np
import pandas as pd
from collections import Counter


import docsim as docsim

docsim_obj = docsim.DocSim(verbose=False)

def convertPercent(x):
    return float(x.strip('%'))/100

def get_course_to_career(path):
    course_to_career = []
    with open(path) as file:
        lines = file.readlines()
        lines = [line.rstrip() for line in lines]
        count = 0
        for l in lines:
            temp_list = []
            count += 1
            if count == 1:
                continue
            temp_list.append(l.split(",")[0])
            temp_list.append(" ".join(l.split(",")[1:]))
            course_to_career.append(temp_list)
    return course_to_career


course_to_career = get_course_to_career("handshake.csv")

data = pd.read_csv("processed_data.tsv", sep='\t', converters={'Response Rate':convertPercent})

#Smart evals provides multiple values for all the individual courses. We will be taking the first value for categorical columns and the mean value of all the rows for numeric columns
data = data.groupby("course_id").agg(
    {'course_name_x': 'first', 'course_desc': 'first', 'units_y': 'first', 'College': 'first',
      'Total # Students': np.mean, '# Responses': np.mean, 'Hrs Per Week': np.mean,
      'Interest in student learning': np.mean, 'Clearly explain course requirements': np.mean,
      'Clear learning objectives & goals': np.mean, 'Instructor provides feedback to students to improve': np.mean,
      'Demonstrate importance of subject matter': np.mean, 'Explains subject matter of course': np.mean,
      'Show respect for all students': np.mean, 'Overall teaching rate': np.mean, 'Overall course rate': np.mean, 'Response Rate': np.mean})


#Filtering out courses with low response rate
#data = data[data['Response Rate'] > 0.50] 


#Smart Evals sub algorithm
data['SmartEvalsScore'] = (2*data['Overall course rate'] + 2*data['Overall teaching rate'] +data['Interest in student learning'] +data['Explains subject matter of course'] +data['Demonstrate importance of subject matter'] +data['Clear learning objectives & goals'])/(8*5)
smartEvelsDict = dict(zip(data['course_name_x'], data['SmartEvalsScore']))

corpus = docsim_obj.embed_doc(data["course_desc"] + data["course_name_x"])



#Calculate semantic matching score for courses based on course name and description
semantic_dict = {}
final_dict = {}
def course_sim(query):
    
    #Sorting according to algorithm score
    similarities = docsim_obj.get_scores(query, corpus)
    for idx, score in (sorted(enumerate(similarities), reverse=True, key=lambda x: x[1])):
        semantic_dict[data.iloc[idx]["course_name_x"]] = score

    
    #Algorithm that gives twice weight to semantic matching    
    for key in semantic_dict:
        final_dict[key] = 2*semantic_dict[key] + smartEvelsDict[key]
    
    
    
    
    relevantJobDict = {}
    count = 0
    for idx, score in (sorted(enumerate(similarities), reverse=True, key=lambda x: x[1])):
        temp_list = []
        count += 1
        for course in course_to_career:
            term_count = 0
            for term in data.iloc[idx]["course_name_x"].strip().split(" "):
                if term in course[1] and len(term) > 2:
                    term_count += 1
                    if term_count > 1 and len(temp_list) < 3 and course[0] not in temp_list:
                        temp_list.append(course[0])
        relevantJobDict[data.iloc[idx]["course_name_x"]] = temp_list
        
    
    
    
    
    
    

    print("For the query: {}, Here are the results: \n\n ".format(query))
    #Store and display top 10 courses
    top10 = Counter(final_dict)    
    sorted_dict2 = top10.most_common(10)
    
    for t in sorted_dict2:
        score = ((t[1]*100)/3.0)
        stylishScore = "{:.2f}%".format(score)
        jobListString = ' '.join(str(v) for v in relevantJobDict[t[0]])
        print("Course:", t[0])
        print("Relevance Score:", stylishScore)
        print("Historically Matched Jobs:", ','.join(str(v) for v in relevantJobDict[t[0]]))
        print('-----------------------------------------------------------\n')

    
    
        
